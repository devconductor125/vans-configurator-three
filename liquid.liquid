<head>
	<meta charset="utf-8">
	<title>Van Configurator</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css" />
	<style>
    #shopify-chat {
      display: none;
    }
    .footer-group {
      display: none !important;
    }
		.threejs-container {
			position: fixed;
      z-index: 100;
      top: 0px;
      left: 0px;
			background: linear-gradient(180deg, #fff 60%, #e4e4e4) !important;
			margin: 0;
			color: #333;
			font-family: Monospace;
			font-size: 13px;
			line-height: 24px; 
			overscroll-behavior: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			overflow: hidden;
      width: 100vw;
      margin: 0 auto;
      margin-bottom: 50px;
      height: 100vh;
			display: flex;
		}
		#configurator-container {
			width: calc(100vw - 300px);
		}
		#side-section {
			width: 300px;
			border-left: 1px solid rgb(159, 159, 159);
			height: 100%;
			z-index: 1;
			background-color: #d3d3d3;
		}
		.d-flex {
			display: flex;
		}
		.items-container {
			position: absolute;
			bottom: 16px;
			left: 50%;
			transform: translateX(-50%);
      max-width: 800px;
		}
		.item-box {
			margin-left: 8px;
			margin-right: 8px;
			border-radius: 15px;
			text-align: center;
			cursor: grab;
			opacity: 0.8;
			transition: opacity .15s ease-in-out, transform .08s linear;
			position: relative;
      margin-bottom: 10px;
      margin-top: 10px;
		}
		.item-box .carted-item {
			position: absolute;
			top: -5px;
			right: -5px;
			background-color: red;
			border-radius: 50%;
			align-items: center;
			justify-content: center;
			width: 25px;
			height: 25px;
			color: white;
      display: none;
		}
		.item-box:active {
			cursor: grabbing;
			cursor: -moz-grabbing;
			cursor: -webkit-grabbing;
		}
		.item-box:hover {
			opacity: 1;
			transform: scale(1.04);
		}
		.item-img {
			width: 100px;
			height: 100px;
			border-radius: 15px;
			background-size: cover;
			box-shadow: 0.6px 0.6px 1.9px rgba(0, 0, 0, .035), 5px 5px 15px rgba(0, 0, 0, .07);
		}
		p {
			font-size: 11px;
			line-height: 1.5;
			margin-bottom: 12px;
		}
		#airconditioner {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/airconditioner-1.jpg?v=1720191621&width=100');
      display: block;
    }

    #maxxair {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/maxxair.jpg?v=1711798448&width=100');
      display: block;
    }

    #solar_panel250 {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/250W.jpg?v=1724133040&width=100');
			display: block;
    }

    #solar_panel200 {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/200W.jpg?v=1711798448&width=100');
      display: block;
    }

    #solar_panel100 {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/100W.jpg?v=1724041152&width=100');
			display: block;
    }

    #solar_panel50 {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/55W.jpg?v=1711798448&width=100');
      display: block;
    }

    #solar_panel30 {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/30W.jpg?v=1711798448&width=100');
      display: block;
    }

    #ladder {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/ladder.jpg?v=1714006260&width=100');
      display: block;
    }
    #cross_bar {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/8020_cross.jpg?v=1717205308&width=100');
      display: block;
    }
    #solar_cross_bar {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/solar_cross.jpg?v=1720093315&width=100');
      display: block;
    }
    #awning {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/awning.jpg?v=1723579211&width=100');
      display: block;
    }
    #awning_350 {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/awning.jpg?v=1723579211&width=100');
      display: block;
    }
    #light_bar {
      background-image: url('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/light_bar.jpg?v=1725399706&width=100');
      display: block;
    }

		button {
			cursor: pointer;
			display: flex;
			justify-content: center;
		}
    button[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }
		.action-btn-list {
			position: absolute;
			bottom: 125px;
			right: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
		}
		.action-btn-list button {
			width: 40px;
			height: 40px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: #333;
			border-radius: 22px;
			border: none;
		}
		.text-center {
			text-align: center;
		}
		.mb-3 {
			margin-bottom: 8px;
		}
		.text-title1 {
			color: #333;
			opacity: 0;
			animation: textAnimation 2s linear 3s infinite alternate;
		}
		.text-body1 {
			color: #333;
			font-size: 20px;
		}
		.items-container>div:first-child {
			position: relative;
			text-align: center;
		}
		@keyframes textAnimation {
			0% {
				opacity: 0;
			}

			100% {
				opacity: 0.7;
			}
		}
    #configurator-container {
      position: relative;
      border-radius: 20px;
    }
    .item-container .announce-bar {
      margin-bottom: 20px !important;
    }
		.van-detail {
			position: absolute;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
		}
		#rack_title {
			font-size: 24px;
			text-shadow: 0px 0px 4px #fff;
			color: black;
		}
		.tooltip .tooltiptext {
			visibility: hidden;
			width: 120px;
			background-color: rgba(17, 12, 46, 1);
			color: #fff;
			text-align: center;
			border-radius: 6px;
			padding: 5px 0;
			top: 35%;
    	margin-left: 10px;
			position: absolute;
			z-index: 1;
			transform: translateY(-23%);
      left: 100%;
		}
		.tooltip:hover .tooltiptext {
			visibility: visible;
		}
		.tooltip .tooltiptext:before {
			content: "";
			display: block;
			width: 0;
			height: 0;
			border-top: 9px solid transparent;
			border-bottom: 9px solid transparent;
			border-left: 9px solid rgba(17,9, 46, 1);
			position: absolute;
			left: -9px;
			top: 50%;
			transform: rotate(180deg) translateY(50%);
		}
    .left-tooltip {
			position: relative;
		}
		.left-tooltip .tooltiptext {
			visibility: hidden;
			width: 120px;
			background-color: rgba(17, 12, 46, 1);
			color: #fff;
			text-align: center;
			border-radius: 6px;
			padding: 5px 0;
			top: 35%;
    	margin-left: 10px;
			position: absolute;
			z-index: 1;
      right: 100%;
			margin-right: 8px;
			transform: translateY(-30%);
		}
		.left-tooltip:hover .tooltiptext {
			visibility: visible;
		}
		.left-tooltip .tooltiptext:after {
			content: "";
			display: block;
			width: 0;
			height: 0;
			border-top: 8px solid transparent;
			border-bottom: 8px solid transparent;
			border-right: 8px solid rgba(17, 9, 46, 1);
			position: absolute;
			top: 50%;
			transform: rotate(180deg) translateY(50%);
			right: -6px;
		}
    [data-tab-content] {
			display: none;
		}
		.active[data-tab-content] {
			display: block;
		}
		.tabs {
			display: flex;
			justify-content: space-around;
			list-style-type: none;
			margin: 0;
			padding: 0;
			border-bottom: 1px solid black;
			position: absolute;
			width: 300px;
			height: 50px;
		}
		.tab {
			cursor: pointer;
			padding: 10px;
			width: 100%;
			text-align: center;
      border-right: 1px solid #676767;
		}
		.tab.active {
			background-color: #676767;
			color: white;
		}
		.tab:hover {
			background-color: #AAA;
		}
		.tab-content {
			height: calc(100vh - 150px);
			overflow-y: auto;
			margin-top: 50px;
			margin-bottom: 100px;
			padding: 10px 10px;
		}
		.checkout-area {
			position: absolute;
			height: 100px;
			bottom: 0;
			width: 300px;
			border-top: 1px solid #333;
		}
		.checkout-area button {
			justify-content: center;
			font-family: "Josefin Sans", sans-serif;
			border-radius: 8px;
			border: 0;
			letter-spacing: 1px;
			color: #fff;
			background: #246eea;
			padding: 12px;
			white-space: nowrap;
			font-size: 16px;
			line-height: 1;
			text-transform: uppercase;
			transition: all 0.15s ease;
			text-decoration: none;
			display: flex;
			align-items: center;
			margin: 0 auto;
			width: 90%;
		}
		.checkout-area button:hover {
			-webkit-transform: translateY(-1px);
      transform: translateY(-1px);
			background: #4984ea;
		}
		#products-detail {
			display: flex;
			justify-content: space-between;
			margin: 0 auto;
			width: 90%;
			margin-top: 10px;
			margin-bottom: 4px;
			font-size: 16px;
			font-weight: bold;
		}
    .unaka-logo {
			position: absolute;
			top: 20px;
			left: 30px;
      z-index: 10;
		}
    .build-item {
			margin-top: 12px;
      border-bottom: 2px solid rgb(134, 134, 134);
      padding-bottom: 10px;
		}
		.build-item .item-overview {
			display: flex;
			align-items: center;
      justify-content: space-between;
		}
    .item-overview .product-info {
      display: flex;
      align-items: center;
    }
		.item-overview .item-name {
			font-size: 12px;
			display: -webkit-box;
			-webkit-line-clamp: 2;
			-webkit-box-orient: vertical;
			overflow: hidden;
			text-overflow: ellipsis;
			word-break: break-all;
      font-weight: bold;
      color: black;
      margin-left: 6px;
      text-decoration: underline;
      line-height: 16px;
		}
    .item-overview .remove-product {
      margin-left: 8px;
      border-radius: 4px;
      font-size: 22px;
    }
		.item-overview img {
			border: 1px solid rgb(134, 133, 133);
    	border-radius: 6px;
			margin-right: 6px;
		}
		.build-item .item-variants {
			margin-top: 6px;
			display: flex;
			flex-direction: column;
			margin-left: 12px;
		}
		.item-variants .variant {
			display: flex;
			align-items: center;
			justify-content: space-between;
      margin: 4px 0;
		}
    .item-variants .variant .selected-variant{
			color: rgb(230, 75, 56);
      font-weight: bold;
		}
		.item-variants .variant div {
			display: flex;
			align-items: center;
		}
		.item-variants .variant input{
			margin: 0;
			margin-right: 4px;
		}
    .item-variants .variant .price{
			font-weight: bold;
		}
    .item-variants .variant label{
			letter-spacing: -0.3px;
      font-size: 11px;
      line-height: 18px;
		}
		.build-item .divider {
			border: 1px solid rgb(159, 159, 159);
		}
    #viewHelper {
      display: flex;
    }
    #side-collapse {
			display: none;
		}
    .select-colors {
			display: flex;
			flex-wrap: wrap;
		}
		.color-item {
      display: block !important;
			width: 29px;
			height: 29px;
			border-radius: 20px;
			border: 2px solid #fff;
			margin: 3px;
			cursor: pointer;
			opacity: 0.7;
		}
		.color-item.color-selected {
			opacity: 1;
		}

    @media only screen and (max-width: 1250px) {
      .items-container {
        max-width: 576px;
      }
    }

    
		@media only screen and (max-width: 1350px) {
			.item-img {
				width: 80px;
				height: 80px;
			}
		}
		@media only screen and (max-width: 1024px) {
			{% comment %} .item-img {
				width: 70px;
				height: 70px;
				margin-bottom: 10px;
			}
			.item-name {
				display: none;
			} {% endcomment %}
			#configurator-container {
				width: 100vw;
			}
			#side-section {
				position: absolute;
				right: -300px;
				transition: right .4s;
				transition-timing-function: linear;
			}
			.van-detail {
				display: none;
			}
			.text-title1 {
				display: none;
			}
			.action-btn-list {
				/* bottom: 160px; */
				right: 8px;
			}
			.unaka-logo img{
				width: 60px;
			}
			#viewHelper {
				display: none;
			}
			#side-collapse {
				display: block;
				position: absolute;
				top: 30vh;
				left: -36px;
    		border: none;
				width: 36px;
				background-color: white;
				border-top-left-radius: 10px;
				border-bottom-left-radius: 10px;
			}
			#side-collapse div {
				padding: 14px 8px;
				transition: all .2s;
				z-index: 10;
			}
			#side-collapse div svg{
				transform: scaleY(2);
			}
			#side-collapse div.collapsed {
				text-align: left;
			}
			#side-collapse div.expanded {
				transform: rotate(180deg);
				text-align: right;
			}
		}

    #select-template {
			padding-top: 10px;
		}
		#select-template .selectable {
			display: flex;
			justify-content: center;
			margin-top: 20px;
			cursor: pointer;
		}
    .not-sell {
      color: red;
      font-size: 12px;
      line-height: 16px;
    }
    .loox-float-toggler-container .closeBtn{
      background-color: white;
      position: absolute;
      top: 9px;
      right: 40px;
      z-index: 1;
      /* color: white; */
      /* padding: 5px; */
      width: 18px;
      height: 18px;
      display: flex;
      justify-content: center;
      /* align-items: center; */
      /* font-size: 14px; */
      border-radius: 10px;
      cursor: pointer;
    }

    .loox-float-toggler-container {
      display: none !important;
    }

    .swiper {
      width: 100%;
      height: 100%;
      padding: 8px 0;
    }

    .swiper-slide {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .swiper-button-next,
    .swiper-button-prev {
      top: 0;
      width: 40px;
      height: 100%;
      color: #37393a;
      display: flex !important;
    }

    .swiper-button-prev {
      left: -32px;
    }

    .swiper-button-next {
      right: -32px;
    }

    @media only screen and (max-width: 700px) {
      .items-container {
        max-width: 100%;
      }

      .item-img {
        width: 70px;
        height: 70px;
      }

      .item-name {
        display: none;
      }

      .swiper-button-next,
      .swiper-button-prev {
        display: none;
      }
    }
    .d-none {
      display: none !important;
    }
    .d-block {
      display: block !important;
    }

    #van_modal_area {
      height: 100vh;
      z-index: 1000;
      width: 100vw;
      display: flex;
      position: absolute;
      align-items: center;
      justify-content: center;
      background-color: #3a3a3a6b;
    }

    .van_modal_content {
      min-width: 400px;
      border-radius: 8px;
      padding: 24px 24px;
      background-color: white;
      max-width: 560px;
    }
    .van_modal_content label {
      font-size: 20px;
      margin: 10px 0px;
      font-weight: bold;
    }
    #van_modal_select {
      width: 100%;
      height: 40px;
      margin: 20px 0px;
      border: 1px solid #333;
      border-radius: 6px;
    }
    .van_select_trigger {
      display: flex;
      justify-content: end;
    }
    .van_select_trigger button{
      justify-content: center;
			font-family: "Josefin Sans", sans-serif;
			border-radius: 8px;
			border: 0;
			letter-spacing: 1px;
			color: #fff;
			background: #246eea;
			padding: 10px 16px;
			white-space: nowrap;
			font-size: 12px;
			line-height: 1;
			text-transform: uppercase;
			transition: all 0.15s ease;
			text-decoration: none;
			display: flex;
			align-items: center;
    }

	</style>
</head>
<div id="van_modal_area">
  <div class="van_modal_content">
    <label>Select Van</label>
    <select id="van_modal_select">
      <option> Premium / Ford Transit 148 High Roof</option>
    </select>
    <div class="van_select_trigger"> 
      <button id='van_select_trigger'>
        Select
      </button>
    </div>
  </div>
</div>
<div class="threejs-container">
  <a class="unaka-logo" href="/">
    <img src="https://cdn.shopify.com/s/files/1/0412/9898/5124/files/Unaka_Brand_v2-03.png?v=1706796409&width=95" draggable="false" width="95" height="95"/>
  </a>
	<div id="configurator-container">
    <div class="van-detail">
      <h2 id="rack_title">Ford Transit Roof Rack - Premium - 148 High Roof</h2>
    </div>
		<div id="container"></div>
    <div class="items-container">
      <div class="swiper">
        <div class="swiper-wrapper drag-items">
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="airconditioner" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Air Conditioner</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="maxxair" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Maxxair</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="solar_panel250" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Solar Panel<br />(250W)</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="solar_panel200" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Solar Panel<br />(200W)</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="solar_panel100" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Solar Panel<br />(100W)</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="solar_panel50" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Solar Panel<br />(55W)</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="solar_panel30" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Solar Panel<br />(30W)</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="ladder" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Ladder</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide" style="display: none">
            <div class="item-box">
              <div class="item-img" id="solar_cross_bar" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Solar cross bar</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="cross_bar" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>8020 cross bar</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="awning" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>F45-300 Awning</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="awning_350" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>F45-350 Awning</p>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="item-box">
              <div class="item-img" id="light_bar" draggable="false">
                <div class="carted-item">1</div>
              </div>
              <div class="item-name">
                <p>Light Bar</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="swiper-button-next"></div>
      <div class="swiper-button-prev"></div>
    </div>
		<div class="action-btn-list">
      <button class="mb-3 left-tooltip" id="deleteButton" disabled>
        <span class="tooltiptext">Delete Items</span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 1024 1024">
          <path fill="#fff"
            d="M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32" />
        </svg>
      </button>

      <button class="mb-3 left-tooltip" id="resetButton" disabled>
        <span class="tooltiptext">Reset Items</span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 21 21">
          <g fill="none" fill-rule="evenodd" stroke="#fff" stroke-linecap="round" stroke-linejoin="round">
            <path d="M6.5 3.5c-2.414 1.377-4 4.022-4 7a8 8 0 1 0 8-8" />
            <path d="M6.5 7.5v-4h-4" />
          </g>
        </svg>
      </button>

      <button class="mb-3 left-tooltip" id="imgDownloadBtn">
        <span class="tooltiptext">Download Image</span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
          <g fill="none" stroke="#ffffff" stroke-linecap="round" stroke-width="1.5">
            <path stroke-linejoin="round"
              d="M21.25 13V8.5a5 5 0 0 0-5-5h-8.5a5 5 0 0 0-5 5v7a5 5 0 0 0 5 5h6.26" />
            <path stroke-linejoin="round"
              d="m3.01 17l2.74-3.2a2.2 2.2 0 0 1 2.77-.27a2.2 2.2 0 0 0 2.77-.27l2.33-2.33a4 4 0 0 1 5.16-.43l2.47 1.91M8.01 10.17a1.66 1.66 0 1 0-.02-3.32a1.66 1.66 0 0 0 .02 3.32" />
            <path stroke-miterlimit="10" d="M18.707 20v-5" />
            <path stroke-linejoin="round" d="m16.414 17.895l1.967 1.967a.459.459 0 0 0 .652 0L21 17.895" />
          </g>
        </svg>
      </button>
		</div>
	</div>
  <div id="side-section">
    <div id="side-collapse" >
      <div class="collapsed">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 256 256"><path fill="currentColor" d="M210.84 205.13a12 12 0 0 1-16 5.71l-152-72a12 12 0 0 1 0-21.68l152-72a12 12 0 1 1 10.27 21.69L76 128l129.1 61.15a12 12 0 0 1 5.74 15.98"/></svg>
      </div>
    </div>
    <ul class="tabs">
      <li data-tab-target="#build-list" class="active tab">Build List</li>
      <li data-tab-target="#rack-tab" class="tab">Van</li>
    </ul>
    <div class="tab-content">
      <div id="build-list" data-tab-content class="active">
      </div>
      <div id="rack-tab" data-tab-content>
        <div>Select van color</div>
        <div class="select-colors" id="color-selectable">
          <div class="color-item color-selected" style="background-color: rgb(255, 255, 255);"></div>
          <div class="color-item" style="background-color: rgb(205, 36, 0);"></div>
          <div class="color-item" style="background-color: rgb(0, 0, 0);"></div>
          <div class="color-item" style="background-color: rgb(173, 175, 184);"></div>
          <div class="color-item" style="background-color: rgb(141 140 144);"></div>
          <div class="color-item" style="background-color: rgb(185, 168, 133);"></div>
          <div class="color-item" style="background-color: rgb(146, 17, 18);"></div>
          <div class="color-item" style="background-color: rgb(72, 115, 163);"></div>
          <div class="color-item" style="background-color: rgb(59, 82, 67);"></div>
          <div class="color-item" style="background-color: rgb(146, 173, 62);"></div>
        </div>
      </div>

    </div>
    <div class="checkout-area">
      <div id="products-detail">
        <div><span id="products-num">0</span> Items</div>
        <div>$<span id="products-cost">0</span></div>
      </div>
      <button id="addCartBtn">
        Checkout
        &nbsp;
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 50 50"><path fill="#fff" d="M25 42c-9.4 0-17-7.6-17-17S15.6 8 25 8s17 7.6 17 17s-7.6 17-17 17m0-32c-8.3 0-15 6.7-15 15s6.7 15 15 15s15-6.7 15-15s-6.7-15-15-15"/><path fill="#fff" d="m24.7 34.7l-1.4-1.4l8.3-8.3l-8.3-8.3l1.4-1.4l9.7 9.7z"/><path fill="#fff" d="M16 24h17v2H16z"/></svg>
      </button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" async></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" async></script>

<script type="importmap" async>
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js"
    }
  }
</script>

<script>
  const tabs = document.querySelectorAll('[data-tab-target]')
  const tabContents = document.querySelectorAll('[data-tab-content]')

  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const target = document.querySelector(tab.dataset.tabTarget)
      tabContents.forEach(tabContent => {
        tabContent.classList.remove('active')
      })
      tabs.forEach(tab => {
        tab.classList.remove('active')
      })
      tab.classList.add('active')
      target.classList.add('active')
    })
  })

  document.getElementById("side-collapse").addEventListener('click', function () {
    let iconElement = this.firstChild.nextSibling
    if(iconElement.classList.contains('expanded')){ 
      iconElement.classList.remove("expanded");
      iconElement.classList.add("collapsed");
      document.getElementById('side-section').style.right = '-300px'
    } else if(iconElement.classList.contains('collapsed')) {
      iconElement.classList.remove("collapsed");
      iconElement.classList.add("expanded");
      document.getElementById('side-section').style.right = '0px'
    }
  });

</script>

<script async src="https://unpkg.com/es-module-shims@1.3.0/dist/es-module-shims.js"></script>
<script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js" async></script>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/loaders/GLTFLoader.js';
  import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/loaders/DRACOLoader.js';
  import { ViewHelper } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/helpers/ViewHelper.js';
  import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/loaders/RGBELoader.js';
  import { GroundedSkybox } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/objects/GroundedSkybox.js';

  var swiper = new Swiper('.swiper', {
    slidesPerView: 6,
    navigation: {
      nextEl: '.swiper-button-next',
      prevEl: '.swiper-button-prev',
    },
  });

  var swiper = new Swiper(".swiper", {
    slidesPerView: 4,
    spaceBetween: 10,
    navigation: {
      nextEl: '.swiper-button-next',
      prevEl: '.swiper-button-prev',
    },
    breakpoints: {
      576: {
        slidesPerView: 5,
        // spaceBetween: 20,
      },
      // 768: {
      //   slidesPerView: 4,
      //   // spaceBetween: 40,
      // },
      1250: {
        slidesPerView: 6,
        // spaceBetween: 50,
      },
    },
  });

  let vanArea = [-16.535, 101.968]; // by inch
  let addedState = [];
  let selectedIndexOfState = -1;
  let solar35Area = [];
  let solar55Area = [];

  let canvas, camera, scene, renderer;
  let cameraType = "perspective";
  let canvasContainer = document.getElementById("container");

  let grid;
  let controls;

  let selectedFeature;
  var targetForDragging;

  let isDragging = false;

  let intersects;
  let raycaster;
  let workPlane;

  let edges;
  let line;
  let edgeLine = null;
  const lineMaterial = new THREE.LineBasicMaterial({ color: "#fff" });

  let vanItem;
  let cloneVanItem = null;
  let loadItemDirectory;

  let carModel;
  let shodowMesh;
  let model = null;

  let helper;
  let clock;
  let offsetTopCanvas

  let selectedItem = '';
  let ladderPlane;
  let cutOffArea = [3.19, 25.7, 32.09, 64.72, 71.11, 85.19];
  let vanDiff = 3.2

  let bodyMaterial;
  let bodyMesh;

  let fromTemplate = false;
  let totalPrice = 0;
  let collidableMeshList = [];
  const meterToInch = 39.3701;

  let availableProducts = [
    {
      "htmlId": "",
      "type": "rack",
      "availability": true,
      "handle": "ford-transit-roof-rack",
      "id": 45730334671067,
      "price": 0,
      "quantity": 1,
      availableVariants: [
        45730334671067,
        45730334703835,
        45730334802139,
        45730334834907
      ],
      "xRadius": null
    },
    {
      "htmlId": "airconditioner",
      "type": "air_conditioner",
      "availability": true,
      "handle": "dometic-rtx-2000",
      "id": 43261478764763,
      "price": 0,
      "quantity": 0,
      "xRadius": 13.18
    },
    {
      "htmlId": "maxxair",
      "type": "maxxair",
      "availability": true,
      "handle": "maxxair-fan-deluxe",
      "id": 40771325264036,
      "price": 0,
      "quantity": 0,
      "xRadius": 11.8
    },
    {
      "htmlId": "solar_panel200",
      "type": "solar200",
      "availability": true,
      "handle": "rich-solar-solar-panel",
      "id": 45977350734043,
      "price": 0,
      "quantity": 0,
      "xRadius": 13.5
    },
    {
      "htmlId": "solar_panel50",
      "type": "solar55",
      "availability": false,
      "handle": "",
      "id": 45081892683995,
      "price": 0,
      "quantity": 0,
      "xRadius": 12.75,
      "title": "Rich Solar Mega 55 Watt 12 Volt Solar Panel",
      "image": "https://cdn.shopify.com/s/files/1/0412/9898/5124/files/Rich-Solar-55W-12V-Solar-Panel_7619b189-0847-457f-b220-26773a5ab5cb.png?v=1717015803",
      "url": "https://shop.explorist.life/shop/all-products/pre-order-rich-solar-55w-12v-solar-panel"
    },
    {
      "htmlId": "solar_panel30",
      "type": "solar30",
      "availability": false,
      "handle": "",
      "id": 45081892683995,
      "price": 0,
      "quantity": 0,
      "xRadius": 16.6,
      "title": "Rich Solar Mega 35 Watt 12 Volt Solar Panel",
      "image": "https://cdn.shopify.com/s/files/1/0412/9898/5124/files/Rich-Solar-35W-12V-Solar-Panel_e5266152-4c97-4d03-8a8c-30e6446a354b.png?v=1717015802",
      "url": "https://shop.explorist.life/shop/all-products/pre-order-rich-solar-35w-12v-solar-panel/"
    },
    {
      "htmlId": "",
      "type": "ac_cross",
      "availability": true,
      "handle": "unaka-roof-rack-cross-bars",
      "id": 45808915775707,
      "price": 0,
      "quantity": 0
    },
    {
      "htmlId": "",
      "type": "solar_cross",
      "availability": true,
      "handle": "unaka-roof-rack-cross-bars",
      "id": 45808915808475,
      "price": 0,
      "quantity": 0
    },
    {
      "htmlId": "",
      "type": "max_cross",
      "availability": true,
      "handle": "unaka-roof-rack-cross-bars",
      "id": 45808915775707,
      "price": 0,
      "quantity": 0
    },
    {
      "htmlId": "ladder",
      "type": "ladder",
      "availability": true,
      "handle": "transit-side-mount-ladder-high-roof",
      "id": 44020238385371,
      "price": 0,
      "quantity": 0
    },
    {htmlId: 'airconditioner-d', type: 'air_conditioner_nodamic', handle: '', id: null, price: 0, quantity: 0, xRadius: 15.5,
      "title": "Rich Solar Mega 35 Watt 12 Volt Solar Panel",
      "image": "https://cdn.shopify.com/s/files/1/0412/9898/5124/files/Rich-Solar-35W-12V-Solar-Panel_e5266152-4c97-4d03-8a8c-30e6446a354b.png?v=1717015802",
      "url": "https://shop.explorist.life/shop/all-products/pre-order-rich-solar-35w-12v-solar-panel/"
    },
    {htmlId: 'cross_bar', type: '8020_crossbar', handle: 'unaka-roof-rack-cross-bars', id: 45808912728283, price: 0, quantity: 0, xRadius: 2.3, availability: true,},
    {htmlId: 'solar_cross_bar', type: 'lshape_cross', handle: '', id: null, price: 0, quantity: 0, xRadius: 14.03},
    {htmlId: 'awning', type: 'awning', handle: 'fiamma-45s', id: 45715079299291, price: 0, xRadius: 59.05, availability: true, quantity: 0},
    {htmlId: '', type: 'awning_bracket', handle: 'fiamma-f45s-awning-8020-or-unistrut-mounting-brackets', id: 45072199287003, availability: true, price: 0, quantity: 0},
    {htmlId: 'solar_panel100', type: 'solar100', handle: 'rich-solar-solar-panel', id: 45977350668507, price: 0, quantity: 0, xRadius: 6.9, availability: true},
    {htmlId: 'solar_panel250', type: 'solar250', handle: 'rich-solar-solar-panel', id: 45977350799579, price: 0, quantity: 0, xRadius: 14.95, "availability": true,},
    {htmlId: 'awning_350', type: 'awning_350', handle: 'fiamma-45s', id: 45715079364827, price: 0, availability: true, xRadius: 68.89, quantity: 0},
    {htmlId: 'light_bar', type: 'light_bar', handle: 'tyri-v48-black-17200-elumen-48-hyperion-series-light-bar', id: 45998626996443, price: 0, availability: true, xRadius: 0, quantity: 0},
  ]
  

  const shadow = new THREE.TextureLoader().load('https://cdn.shopify.com/s/files/1/0412/9898/5124/files/ford_ao.png?v=1711858184');

  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath('https://res.cloudinary.com/dbloegsbv/raw/upload/v1/jsm/');

  const loader = new GLTFLoader();
  loader.setDRACOLoader(dracoLoader);

  let delelteBtn = document.getElementById("deleteButton")

  canvasContainer.addEventListener('mousedown', (event) => {
    if (event.button === 0) {
      offsetTopCanvas = canvasContainer.getBoundingClientRect().top;
      isDragging = true;
      doMouseDown(event.clientX, event.clientY - offsetTopCanvas);
    }
  });

  canvasContainer.addEventListener('mousemove', (event) => {
    if (selectedFeature) {
      if (selectedFeature.parent.name !== "van" && selectedFeature.name !== "ladder" && !selectedFeature.name.includes("light_bar")  && !selectedFeature.name.includes('roof_rack')) {
        if (isDragging) {
          offsetTopCanvas = canvasContainer.getBoundingClientRect().top;
          let a = 2 * (event.clientX / ((window.innerWidth < 1024 ? window.innerWidth: window.innerWidth - 300))) - 1;
          let b = 1 - 2 * (event.clientY - offsetTopCanvas) / (window.innerHeight);
          raycaster.setFromCamera(new THREE.Vector2(a, b), camera);
          intersects = raycaster.intersectObject(targetForDragging);
          if (intersects.length === 0) {
            return;
          }

          let objectHit = intersects[0].object;
          let locationX = intersects[0].point.x;
          let locationZ = intersects[0].point.z;
          let coords = new THREE.Vector3(locationX, 0, locationZ);
          coords = scene.worldToLocal(coords);

          const boundingBox = new THREE.Box3().setFromObject(selectedFeature);
          const size = new THREE.Vector3();
          boundingBox.getSize(size);

          const selectedFeatureWidth = size.x;
          let checkCollision = true;
          const xPos = Math.min(0.428 - selectedFeatureWidth / 2, Math.max(-2.115, coords.x));

          if(selectedFeature.name == "awning" || selectedFeature.name == "awning_350"){
            const bbox1  = getModelBoundingBox(selectedFeature);
            const widthOfObject = Math.abs(bbox1.max.x - bbox1.min.x);
            const xPos = Math.min(0.778 - selectedFeatureWidth / 2, Math.max(-2.93 + widthOfObject/2, coords.x));
            selectedFeature.parent.position.x = xPos;
          } else if(selectedFeature.name == "air_conditioner"){
            const bbox1 = getModelBoundingBox(selectedFeature);
            let solarModels = scene.children.filter((group) => group?.children[0]?.name == "solar30");
            const solarBoxes = solarModels.map((model) => {
              return getModelBoundingBox(model)
            });

            if(solarBoxes.length > 0) {
              const connectedSolar = solarBoxes.filter(solar => solar.max.x > bbox1.max.x && solar.min.x < bbox1.min.x)[0];
              if(connectedSolar) return;
            }
            const widthOfObject = Math.abs(bbox1.max.x - bbox1.min.x);
            const xPos = Math.min(0.428 - selectedFeatureWidth / 2, Math.max((- vanArea[1] * 0.0254) + widthOfObject/2, coords.x));
            collidableMeshList = updateColliderList();
            const checkCollision = isCrossBarCollied(bbox1, collidableMeshList, xPos);
            if(isValueInScale(coords.x * 1000 / 25.4 * -1, cutOffArea, 7.001, vanDiff)  >= 0 && !checkCollision) {
              updateSolarArea(xPos, selectedFeature.name, 2)
              selectedFeature.parent.position.x = xPos;
              selectedFeature.parent.position.z = 0;
              updateModelState(2, selectedFeature.name, xPos) 
            } 
          } else if(selectedFeature.name == 'maxxair'){
            const bbox1 = getModelBoundingBox(selectedFeature);
            let solarModels = scene.children.filter((group) => group?.children[0]?.name == "solar55");
            const solarBoxes = solarModels.map((model) => {
              return getModelBoundingBox(model)
            });

            if(solarBoxes.length > 0) {
              const connectedSolar = solarBoxes.filter(solar => solar.max.x > bbox1.max.x && solar.min.x < bbox1.min.x)[0];
              if(connectedSolar) return;
            }
            const widthOfObject = Math.abs(bbox1.max.x - bbox1.min.x);
            const xPos = Math.min(0.428 - selectedFeatureWidth / 2, Math.max((- vanArea[1] * 0.0254) + widthOfObject/2, coords.x));
            collidableMeshList = updateColliderList();
            const checkCollision = isCrossBarCollied(bbox1, collidableMeshList, xPos);
            if(isValueInScale(coords.x * 1000 / 25.4 * -1, cutOffArea, 7, vanDiff) >= 0 && !checkCollision){
              updateSolarArea(xPos, selectedFeature.name, 2)
              selectedFeature.parent.position.x = xPos;
              selectedFeature.parent.position.z = 0;
              updateModelState(2, selectedFeature.name, xPos)
            } 
          } else if(selectedFeature.name == 'solar30') {
            const bbox1  = getModelBoundingBox(selectedFeature);
            let acmodels = scene.children.filter((group) => group?.children[0]?.name == "air_conditioner");
            const acboxes = acmodels.map((model) => {
              return getModelBoundingBox(model)
            });
            const acBox = acboxes.filter(acbox => acbox.max.x < bbox1.max.x && acbox.min.x > bbox1.min.x)[0];
            if(acBox) {
              const centerOfBox = (acBox.min.x + acBox.max.x) /2;
              const maxMovable = centerOfBox + 3.8 * 0.0254
              const minMovable = centerOfBox - 3.8 * 0.0254
              const widthOfObject = Math.abs(bbox1.max.x - bbox1.min.x);
              let xPos = Math.min(0.428 - selectedFeatureWidth / 2, Math.max((- vanArea[1] * 0.0254) + widthOfObject/2, coords.x));
              collidableMeshList = updateColliderList();
              const checkCollision = isColliedNearBy(bbox1, acBox, collidableMeshList, xPos);
              if(xPos <= maxMovable && xPos >= minMovable && !checkCollision) {
                selectedFeature.parent.position.x = xPos
              }
            }
          } else if(selectedFeature.name == 'solar55') {
            const bbox1  = getModelBoundingBox(selectedFeature);
            let acmodels = scene.children.filter((group) => group?.children[0]?.name == "maxxair");
            const fanBoxes = acmodels.map((model) => {
              return getModelBoundingBox(model)
            });
            const fanBox = fanBoxes.filter(fanbox => fanbox.max.x < bbox1.max.x && fanbox.min.x > bbox1.min.x)[0];
            if(fanBox) {
              const centerOfBox = (fanBox.min.x + fanBox.max.x) /2;
              const maxMovable = centerOfBox + 0.025
              const minMovable = centerOfBox - 0.025
              const widthOfObject = Math.abs(bbox1.max.x - bbox1.min.x);
              let xPos = Math.min(0.428 - selectedFeatureWidth / 2, Math.max((- vanArea[1] * 0.0254) + widthOfObject/2, coords.x));
              collidableMeshList = updateColliderList();
              const checkCollision = isColliedNearBy(bbox1, fanBox, collidableMeshList, xPos);
              if(xPos <= maxMovable && xPos >= minMovable && !checkCollision) {
                selectedFeature.parent.position.x = xPos
              }
            }
          } else if(selectedFeature.name == "8020_crossbar") {
            const bbox1  = getModelBoundingBox(selectedFeature);
            const widthOfObject = Math.abs(bbox1.max.x - bbox1.min.x);
            let xPos = Math.min(0.428 - selectedFeatureWidth / 2, Math.max((- vanArea[1] * 0.0254) + widthOfObject/2, coords.x));
            collidableMeshList = updateColliderList();
            const checkCollision = isCrossBarCollied(bbox1, collidableMeshList, xPos);
            if(!checkCollision) {
              selectedFeature.parent.position.x = xPos;
              selectedFeature.parent.position.z = 0;
            }
          } else if(selectedFeature.name == "lshape_cross"){
            const bbox1  = getModelBoundingBox(selectedFeature);
            const widthOfObject = Math.abs(bbox1.max.x - bbox1.min.x);
            let xPos = Math.min(0.428 - selectedFeatureWidth / 2, Math.max((- vanArea[1] * 0.0254) + widthOfObject/2, coords.x));
            collidableMeshList = updateColliderList();
            const checkCollision = isCrossBarCollied(bbox1, collidableMeshList, xPos);
            if(!checkCollision) {
              selectedFeature.parent.position.x = xPos;
              selectedFeature.parent.position.z = 0;
            }
          }
          else {
            // if(checkCollision) {
            //   selectedFeature.parent.position.x = xPos;
            //   selectedFeature.parent.position.z = 0;
            //   updateModelState(2, selectedFeature.name, xPos)
            // }
            const bbox1 = getModelBoundingBox(selectedFeature);
            const widthOfObject = Math.abs(bbox1.max.x - bbox1.min.x);
            let xPos = Math.min(0.428 - selectedFeatureWidth / 2, Math.max((- vanArea[1] * 0.0254) + widthOfObject/2, coords.x));
            collidableMeshList = updateColliderList();
            const checkCollision = isCrossBarCollied(bbox1, collidableMeshList, xPos);
            if(!checkCollision) {
              selectedFeature.parent.position.x = xPos;
              selectedFeature.parent.position.z = 0;
            }
          }
          render();
        }
      }
      controls.enableRotate = false;
    }
    else {
      controls.enableRotate = true;
    }
  });

  canvasContainer.addEventListener('mouseup', () => {
    isDragging = false;
  });
  
  document.addEventListener('DOMContentLoaded', function () {
    canvas = document.querySelector('canvas[data-engine="three.js r162"]');
  });

  document.getElementById('color-selectable').addEventListener('click', function(event) {

    if(event.target.classList.contains("color-item")) {
      const options = document.querySelectorAll('.color-item');
      options.forEach(option => {
        option.classList.remove('color-selected')
      })
      event.target.classList.add('color-selected');
      bodyMaterial = new THREE.MeshPhysicalMaterial( {
        color: event.target.style.backgroundColor ?? 0xffffff, metalness: 1.0, roughness: 0.9, clearcoat: 1.0, clearcoatRoughness: 0.08
      });
      bodyMesh.material = bodyMaterial
    }
  })

  document.getElementById('deleteButton').addEventListener('click', function () {
    if (selectedFeature) {
      scene.remove(selectedFeature.parent);
      this.disabled = true;
      calcPrice(selectedFeature.name, false, null)
      updateModelState(3, selectedFeature.name, selectedFeature.parent.position.x)
      render();
      selectedFeature = null;
    }
    let totalQuantity = 0;

    availableProducts.map((product) => {
      if (product.type != 'rack') totalQuantity += product.quantity;
    })
    if (totalQuantity === 0)
      handleDisableResetBtn()
  });

  function handleEnableResetBtn() {
    let resetBtn = document.getElementById("resetButton");
    resetBtn.disabled = false;
  }
  function handleDisableResetBtn() {
    let resetBtn = document.getElementById("resetButton");
    resetBtn.disabled = true;
  }

  document.getElementById('addCartBtn').addEventListener('click', async function() {
    let cartItems = []
    availableProducts.map((product) => {
      if(product.price > 0 && product.quantity > 0) {
        cartItems.push({
          'id': product.id,
          'quantity': product.quantity
        })
      }
    });

    const formData = {'items': cartItems};

    if(cartItems.length > 0) {
      let token = '';
      await fetch(window.Shopify.routes.root + 'cart/clear.js',{
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
      })
      .then(response => {
        return response.json();
      })
      .then((data) => {
        token = data.token;
      })
      .catch((error) => {
        console.error('Error:', error);
        return false;
      });

      await fetch(window.Shopify.routes.root + 'cart/add.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(formData)
      })
      .then(response => {
        return response.json();
      })
      .then((addedData) => {
        gotoCheckout(token)
      })
      .catch((error) => {
        console.error('Error:', error);
        return false;
      });
    } 
  });

  document.getElementById('imgDownloadBtn').addEventListener('click', function (event) {
    renderer.render(scene, camera);

    var webGLCanvas = renderer.domElement;
    var webGLImage = webGLCanvas.toDataURL('image/png');

    var images = document.querySelectorAll('.threejs-container img');
    var imagePromises = Array.from(images).map(img => {
      return new Promise((resolve, reject) => {
        if (img.complete) {
          resolve();
        } else {
          img.onload = resolve;
          img.onerror = reject;
          img.crossOrigin = 'anonymous';
        }
      });
    });

    Promise.all(imagePromises).then(() => {
      const buildList = document.querySelector('#build-list');
      const tempContainer = document.createElement('div');
      tempContainer.style.position = 'absolute';
      tempContainer.style.top = '-9999px';
      tempContainer.style.left = '-9999px';
      document.body.appendChild(tempContainer);

      const canvasClone = webGLCanvas.cloneNode(true);
      const buildListClone = buildList.cloneNode(true);
      const buildItemsClone = buildListClone.querySelectorAll(".build-item");
      const dividers = buildListClone.querySelectorAll(".divider");
      const removeProductBtns = buildListClone.querySelectorAll(".remove-product");
      const itemName = buildListClone.querySelectorAll(".item-name");
      const canvas = document.querySelector("canvas");
      let canvasWidth = parseInt(canvas.style.width, 10);

      buildListClone.style.cssText = `width: ${canvasWidth}; display: flex; flex-wrap: wrap; padding: 24px 0`;

      buildItemsClone.forEach((item, index) => {
        item.style.cssText = "margin-left: 8px; margin-right: 8px; border: 1px solid #333; padding: 12px; border-radius: 8px;";

        if (canvasWidth >= 0 && canvasWidth < 600) {
          item.style.width = "100%";
        } else if (canvasWidth >= 600 && canvasWidth < 1200) {
          item.style.width = "calc(50% - 16px)";
        } else {
          item.style.width = "calc(33.33% - 16px)";
        }

      })

      dividers.forEach((item, index) => {
        item.style.display = "none";
      })
      removeProductBtns.forEach((item, index) => {
        item.style.display = "none";
      })
      itemName.forEach((item, index) => {
        item.style.cssText = "line-height: 2; text-decoration: none !important;";
      })

      tempContainer.appendChild(canvasClone);
      tempContainer.appendChild(buildListClone);

      return html2canvas(tempContainer, {
        useCORS: true, 
      }).then(htmlCanvas => {
        document.body.removeChild(tempContainer);

        var combinedCanvas = document.createElement('canvas');
        combinedCanvas.width = htmlCanvas.width;
        combinedCanvas.height = htmlCanvas.height;
        var context = combinedCanvas.getContext('2d');

        context.drawImage(htmlCanvas, 0, 0);

        var webGLImageElement = new Image();
        webGLImageElement.src = webGLImage;
        webGLImageElement.onload = function () {
          context.drawImage(webGLImageElement, 0, 0);

          var combinedImageData = combinedCanvas.toDataURL('image/png');

          var link = document.createElement('a');
          link.download = 'scene.png';
          link.href = combinedImageData;
          link.click();

          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF({
            orientation: 'portrait',
            unit: 'px',
            format: [combinedCanvas.width, combinedCanvas.height]
          });

          pdf.addImage(combinedImageData, 'PNG', 12, 12, combinedCanvas.width - 24, combinedCanvas.height - 24);
          pdf.save('scene.pdf');
        };

        const radioButtons = buildList.querySelectorAll('.variant-handler');
        radioButtons.forEach(radio => {
          if (radio.hasAttribute('checked')) {
            radio.checked = true;
          } else {
            radio.checked = false;
          }
        });
      });
    }).catch(error => {
      console.error('An error occurred while capturing the content:', error);
    });
  });

  document.getElementById('van_select_trigger').addEventListener('click', function () {
    selectVan();
  });

  document.getElementById('resetButton').addEventListener('click', resetConfig);

  var productElements = document.getElementsByClassName("item-img");

	for (var i = 0; i < productElements.length; i++) {
    productElements[i].addEventListener('click', event => { handleClickProduct(event); handleEnableResetBtn(); }, false);
  }

  function getPrices() {
    const dataPromises = availableProducts.map(async (product) => {
      if(product.availability) {
        const response = await fetch(window.Shopify.routes.root + `products/${product.handle}.js`);
        const productData = await response.json();
        return productData;
      } 
      else return product;
    });
   
    Promise.all(dataPromises)
      .then(data => {
        const priceProducts = availableProducts.map((product, index) => {
          let productPrice = 0;
          const productData = data[index];

          if(product.type == "rack") {
            const rackVariants = productData?.variants ?? [];
            if(rackVariants && rackVariants.length > 0) {
              let vanSelectTxt = ""

              rackVariants.forEach((variant) => {
                if(product?.availableVariants?.includes(variant.id)) {
                  vanSelectTxt += "<option value='"+variant.id+"'>"+variant.name.split("-")[1]+"</option>"
                }
              })
              document.getElementById("van_modal_select").innerHTML = vanSelectTxt
            }
          }

          if (productData.id === product.id) {
            productPrice = productData.price / 100;
          } else {
            const variant = productData.variants.find(variant => variant.id === product.id);
            if (variant) {
              productPrice = variant.price / 100;
            }
          }
          if(product.type == 'rack') {
            totalPrice = productPrice;
            document.getElementById('products-num').innerHTML = 1
            document.getElementById("products-cost").innerHTML = productPrice;
          }
          return { ...product, price: productPrice, title: productData?.title, image: productData?.featured_image ?? product.image, variants: productData?.variants, url: productData?.url };
        });

        updateBuildState(priceProducts);
        availableProducts = priceProducts
      })
      .catch(error => console.error('Error fetching product data:', error));
  }

  getPrices();

  function excludeRanges(vanArea, addedState) {
    let ranges = [];
    for (let i = 0; i < addedState.length; i += 2) {
        ranges.push([addedState[i], addedState[i + 1]]);
    }
    ranges.sort((a, b) => a[0] - b[0]);
    let result = [];
    let currentStart = vanArea[0];
    let currentEnd = vanArea[1];

    for (let range of ranges) {
      let [rangeStart, rangeEnd] = range;
      if (rangeStart > currentEnd) continue;
      if (rangeStart > currentStart) {
          result.push(currentStart, rangeStart);
      }
      currentStart = Math.max(currentStart, rangeEnd);
    }

    if (currentStart < currentEnd) {
      result.push(currentStart, currentEnd);
    }
    return result;
	}

	function findFittingIntervalIndex(result, radius) {
    let requiredLength = 2 * radius;
    for (let i = 0; i < result.length; i += 2) {
      let intervalStart = result[i];
      let intervalEnd = result[i + 1];
      if (intervalEnd - intervalStart >= requiredLength) {
        return i;
      }
    }
    return -1;
	}

	function getIntersectionIntervals(intervals1, intervals2, diff, centerDevi = 0) {
    let intersections = [];

    for (let i = 0; i < intervals1.length; i += 2) {
      let start1 = intervals1[i];
      let end1 = intervals1[i + 1];

      for (let j = 0; j < intervals2.length; j += 2) {
        let start2 = intervals2[j] - diff + centerDevi - vanDiff;
        let end2 = intervals2[j + 1] + diff + centerDevi - vanDiff;
        let maxStart = Math.max(start1, start2);
        let minEnd = Math.min(end1, end2);
        if (maxStart < minEnd) {
            intersections.push(maxStart, minEnd);
        }
      }
    }
    return intersections;
	}

  function updateCrossBars(posX, type, radius) {
    if(type == 'maxxair' || type == 'air_conditioner') {
      const startPoint = posX * 1 + (radius * 2.54 / 100)
      const endPoint = posX * 1 - (radius * 2.54 / 100)
      const lcrossBars = scene.children.filter(group => group?.children[0]?.name == "lshape_cross");
      let overLapped = false;
      let overLappedWidth = 0;
      lcrossBars.map((crossbar) => {
        const crossXPos = crossbar?.position?.x;
        const barStartPoint = crossXPos + 0.3435 + 0.02;
        if(barStartPoint > endPoint) {
          overLapped = true;
          overLappedWidth = Math.abs(barStartPoint - endPoint);
        }
        if(overLapped) {
          crossbar.position.x = crossXPos - overLappedWidth
          if(crossXPos - overLappedWidth < -2.4) {
            scene.remove(crossbar);
          }
        }
      })

    } else if (type == 'solar200') {
      const lcrossBars = scene.children.filter(group => group?.children[0]?.name == "lshape_cross");
      let updatedBars = lcrossBars.map((crossbar) => {
        const crossXPos = crossbar?.position?.x;
        if(Math.abs(crossXPos - posX) < 0.687) {
          scene.remove(crossbar);
          return null
        }
        return crossbar;
      }).filter(Boolean);
      const solarPanels = scene.children.filter(group => group?.children[0]?.name == "solar200" || group?.children[0]?.name == "solar100" || group?.children[0]?.name == "solar250");
      if(updatedBars.length > solarPanels.length + 1) {
        scene.remove(updatedBars[0]);
      }
    } else {
      console.log(posX, type, radius)
    }
  }

  function getAddedState() {
    const itemsToBeCalc = ['maxxair', 'solar200', 'solar250', 'solar100', 'air_conditioner','8020_crossbar', 'solar30', 'solar55'];
    const itemsToCalc = scene.children.filter(group => itemsToBeCalc.includes(group?.children[0]?.name));
    const boxes = itemsToCalc.map((model) => {
      return getModelBoundingBox(model)
    });
    const curState = createOrderedArray(boxes);
    return curState;
  }

	function getAvailablePoint(selectedItem) {
		const curState = getAddedState();
		let result = excludeRanges(vanArea, curState);

		if(selectedItem.type == 'air_conditioner') {
			if(fromTemplate) {
        console.log("From Template");
        let intersections = getIntersectionIntervals(result, cutOffArea, selectedItem.xRadius - 7.0, 5.2);
        let canIndex = findFittingIntervalIndex(intersections, selectedItem.xRadius);
        let xCenter = intersections[canIndex] + selectedItem.xRadius;
        let positionX = -1 * xCenter * 0.0254;
        return positionX;

      } else {
        let intersections = getIntersectionIntervals(result, cutOffArea, selectedItem.xRadius - 7.2);
        console.log("intersections: ", intersections, result);

        let canIndex = findFittingIntervalIndex(intersections, selectedItem.xRadius);
        console.log("canIndex: ", canIndex);

        let xCenter = intersections[canIndex] + selectedItem.xRadius;
        let positionX = -1 * xCenter * 0.0254;
        return positionX;
      }
		} else if(selectedItem.type == 'maxxair') {
			let intersections = getIntersectionIntervals(result, cutOffArea, selectedItem.xRadius - 7, 3.225);
			let canIndex = findFittingIntervalIndex(intersections, selectedItem.xRadius);
			let xCenter = intersections[canIndex] + selectedItem.xRadius;
			let positionX = -1 * xCenter * 0.0254;
			return positionX;
		} else {
			let canIndex = findFittingIntervalIndex(result, selectedItem.xRadius);
			let xCenter = result[canIndex] + selectedItem.xRadius;
			let positionX = -1 * xCenter * 0.0254;
			return positionX;
		}

	}

  function findNearestItems(boxesArr, xValue) {
    let itemLessThanX = null;
    let itemGreaterThanX = null;
    let smallestDiffLessThanX = Infinity;
    let smallestDiffGreaterThanX = Infinity;

    boxesArr.forEach(box => {
        const maxDiff = Math.abs(box.max.x - xValue);
        const minDiff = Math.abs(box.min.x - xValue);

        if (box.max.x < xValue && maxDiff < smallestDiffLessThanX) {
            smallestDiffLessThanX = maxDiff;
            itemLessThanX = box;
        }

        if (box.min.x > xValue && minDiff < smallestDiffGreaterThanX) {
            smallestDiffGreaterThanX = minDiff;
            itemGreaterThanX = box;
        }
    });

    if (itemGreaterThanX && itemLessThanX) {
        return [itemGreaterThanX, itemLessThanX];
    } else if (itemGreaterThanX) {
        return [itemGreaterThanX];
    } else if (itemLessThanX) {
        return [itemLessThanX];
    } else {
        // If no items satisfy the conditions, return the nearest single item
        let nearestItem = null;
        let smallestDifference = Infinity;

        boxesArr.forEach(box => {
            const minDifference = Math.abs(box.min.x - xValue);
            const maxDifference = Math.abs(box.max.x - xValue);
            const currentDifference = Math.min(minDifference, maxDifference);

            if (currentDifference < smallestDifference) {
                smallestDifference = currentDifference;
                nearestItem = box;
            }
        });

        return [nearestItem];
    }
  }

	function handleClickProduct(event){
		let positionX = 0;
		let positionY = 2.35;
		let positionZ = 0;
		model = null;
		vanItem = event.target;
		let selectedItem = availableProducts.filter(product => product.htmlId == event.target.id)[0];
		if(!selectedItem) return;

		if(selectedItem.type == 'ladder') {
			if(selectedItem.quantity > 0 ) return false;
			positionX = -0.6;
			positionY = 1.1717;
			positionZ = -0.97864;
		} else if(selectedItem.type == 'awning' || selectedItem.type == 'awning_350') {
      const awningModels = scene.children.filter((group) => group?.children[0]?.name == "awning" || group?.children[0]?.name == "awning_350");
      if(awningModels.length >= 1) return;

			if(selectedItem.quantity > 0 ) return false;
			positionX = -1.07;
			positionY = 2.35;
			positionZ = 0.84;
		} else if(selectedItem.type == 'light_bar') {
      const rackModel = scene.children.filter((group) => group?.children[0]?.name == "roof_rack_ext");
			if(selectedItem.quantity > 0 ) return false;
      if(rackModel.length >= 1){
        positionX = 0.45149;
        positionY =  2.387;
        positionZ = 0;
      } else return false;
		} else{
			positionY = 2.35;
			positionZ = 0;
			if(selectedItem.type == 'solar30') {
				let acItem = availableProducts.filter(product => fromTemplate ? (product.type == 'air_conditioner_nodamic') : (product.type == 'air_conditioner'))[0];
				if (selectedItem.quantity >= acItem.quantity) return false;

				let acModels = scene.children.filter((group) => 
        group?.children[0]?.name == "air_conditioner");
        
        let solarModels = scene.children.filter((group) => 
          group?.children[0]?.name == "solar30");

        const acBoxes = acModels.map((model) => {
          return getModelBoundingBox(model)
        });

        const solarBoxes = solarModels.map((model) => {
          return getModelBoundingBox(model)
        });

        if(acBoxes.length != solarBoxes.length) {
          if(solarBoxes.length == 0) {
            positionX = acBoxes[0].min.x + Math.abs(acBoxes[0].min.x - acBoxes[0].max.x)/2
            const solarModel = availableProducts.filter(product => product.type == "solar30");
            const solarWidth = solarModel[0].xRadius * 2.54 / 100 * 2; // width of solar panel
            collidableMeshList = updateColliderList();
            const filteredList = collidableMeshList.filter(mesh => mesh.min.x.toFixed(4) != acBoxes[0].min.x.toFixed(4));
            const nearestItems = findNearestItems(filteredList, positionX)

            if(nearestItems.length && nearestItems.length == 1) {
              if(nearestItems[0].min.x > positionX && Math.abs((- vanArea[1] * 0.0254) - nearestItems[0].min.x) > solarWidth){
                if(Math.abs(positionX - nearestItems[0].min.x) < solarWidth/2) {
                  positionX = nearestItems[0].min.x - solarWidth/2;
                }
              } else if(nearestItems[0].max.x < positionX) {
                if(Math.abs(positionX - nearestItems[0].max.x) < solarWidth/2) {
                  positionX = nearestItems[0].max.x + solarWidth/2;
                }
              } else return
            } else if(nearestItems.length == 2) {
              if(nearestItems[0].min.x > positionX && nearestItems[1].max.x < positionX && Math.abs(nearestItems[0].min.x - nearestItems[1].max.x) > solarWidth) {
                if(Math.abs(positionX - nearestItems[0].min.x) < solarWidth/2) {
                  positionX = nearestItems[0].min.x - solarWidth/2;
                } else if(Math.abs(positionX - nearestItems[1].max.x) < solarWidth/2) {
                  positionX = nearestItems[1].max.x  + solarWidth/2;
                }
              } else return;
            } else return;
          } else {
            const filterACs = acBoxes.filter(acbox => {
              solarBoxes.forEach(solarbox => {
                if(acbox.min.x > solarbox.min.x && acbox.max.x < solarbox.max.x) {
                  console.log(acbox)
                } else {
                  positionX = acbox.max.x - Math.abs(acbox.max.x - acbox.min.x)/2

                  // checking available to add
                  const solarModel = availableProducts.filter(product => product.type == "solar30");
                  const solarWidth = solarModel[0].xRadius * 2.54 / 100 * 2; // width of solar panel
                  collidableMeshList = updateColliderList();
                  const filteredList = collidableMeshList.filter(mesh => mesh.min.x.toFixed(4) != acbox.min.x.toFixed(4));
                  const nearestItems = findNearestItems(filteredList, positionX)

                  if(nearestItems.length && nearestItems.length == 1) {
                    if(nearestItems[0].min.x > positionX && Math.abs((- vanArea[1] * 0.0254) - nearestItems[0].min.x) > solarWidth){
                      if(Math.abs(positionX - nearestItems[0].min.x) < solarWidth/2) {
                        positionX = nearestItems[0].min.x - solarWidth/2;
                      }
                    } else return
                  } else if(nearestItems.length == 2) {
                    if(nearestItems[0].min.x > positionX && nearestItems[1].max.x < positionX && Math.abs(nearestItems[0].min.x - nearestItems[1].max.x) > solarWidth) {
                      if(Math.abs(positionX - nearestItems[0].min.x) < solarWidth/2) {
                        positionX = nearestItems[0].min.x - solarWidth/2;
                      } else if(Math.abs(positionX - nearestItems[1].max.x) < solarWidth/2) {
                        positionX = nearestItems[1].max.x  + solarWidth/2;
                      }
                    } else return;
                  }
                }
              })
            })
          }
        } else return;
			} else if(selectedItem.type == 'solar55') {
				let fanItem = availableProducts.filter(product => product.type == 'maxxair')[0];
				if (selectedItem.quantity >= fanItem.quantity) return false;
        let acModels = scene.children.filter((group) => 
        group?.children[0]?.name == "maxxair");
        
        let solarModels = scene.children.filter((group) => 
          group?.children[0]?.name == "solar55");

        const fanBoxes = acModels.map((model) => {
          return getModelBoundingBox(model)
        });

        const solarBoxes = solarModels.map((model) => {
          return getModelBoundingBox(model)
        });

        if(fanBoxes.length != solarBoxes.length) {
          if(solarBoxes.length == 0) {
            positionX = fanBoxes[0].min.x + Math.abs(fanBoxes[0].min.x - fanBoxes[0].max.x)/2
            const solarModel = availableProducts.filter(product => product.type == "solar55");
            const solarWidth = solarModel[0].xRadius * 2.54 / 100 * 2; // width of solar panel
            collidableMeshList = updateColliderList();
            const filteredList = collidableMeshList.filter(mesh => mesh.min.x.toFixed(4) != fanBoxes[0].min.x.toFixed(4));
            const nearestItems = findNearestItems(filteredList, positionX)

            if(nearestItems.length && nearestItems.length == 1) {
              if(nearestItems[0].min.x > positionX && Math.abs((- vanArea[1] * 0.0254) - nearestItems[0].min.x) > solarWidth){
                if(Math.abs(positionX - nearestItems[0].min.x) < solarWidth/2) {
                  positionX = nearestItems[0].min.x - solarWidth/2;
                }
              } else if(nearestItems[0].max.x < positionX) {
                if(Math.abs(positionX - nearestItems[0].max.x) < solarWidth/2) {
                  positionX = nearestItems[0].max.x + solarWidth/2;
                }
              } else return
            } else if(nearestItems.length == 2) {
              if(nearestItems[0].min.x > positionX && nearestItems[1].max.x < positionX && Math.abs(nearestItems[0].min.x - nearestItems[1].max.x) > solarWidth) {

                if(Math.abs(positionX - nearestItems[0].min.x) < solarWidth/2) {
                  positionX = nearestItems[0].min.x - solarWidth/2;
                } else if(Math.abs(positionX - nearestItems[1].max.x) < solarWidth/2) {
                  positionX = nearestItems[1].max.x  + solarWidth/2;
                }

              } else return;
            } else return;
          } else {
            const filterACs = fanBoxes.filter(acbox => {
              solarBoxes.forEach(solarbox => {
                if(acbox.min.x > solarbox.min.x && acbox.max.x < solarbox.max.x) {
                  console.log(acbox)
                } else {
                  positionX = acbox.max.x - Math.abs(acbox.max.x - acbox.min.x)/2

                  // checking available to add
                  const solarModel = availableProducts.filter(product => product.type == "solar55");
                  const solarWidth = solarModel[0].xRadius * 2.54 / 100 * 2; // width of solar panel
                  collidableMeshList = updateColliderList();
                  const filteredList = collidableMeshList.filter(mesh => mesh.min.x.toFixed(4) != acbox.min.x.toFixed(4));
                  const nearestItems = findNearestItems(filteredList, positionX)

                  if(nearestItems.length && nearestItems.length == 1) {
                    if(nearestItems[0].min.x > positionX && Math.abs((- vanArea[1] * 0.0254) - nearestItems[0].min.x) > solarWidth){
                      if(Math.abs(positionX - nearestItems[0].min.x) < solarWidth/2) {
                        positionX = nearestItems[0].min.x - solarWidth/2;
                      }
                    } else return
                  } else if(nearestItems.length == 2) {
                    if(nearestItems[0].min.x > positionX && nearestItems[1].max.x < positionX && Math.abs(nearestItems[0].min.x - nearestItems[1].max.x) > solarWidth) {
                      if(Math.abs(positionX - nearestItems[0].min.x) < solarWidth/2) {
                        positionX = nearestItems[0].min.x - solarWidth/2;
                      } else if(Math.abs(positionX - nearestItems[1].max.x) < solarWidth/2) {
                        positionX = nearestItems[1].max.x  + solarWidth/2;
                      }
                    } else return;
                  }
                }
              })
            })
          }
        } else {
          return;
        }
			} else {
        if(selectedItem.type == '8020_crossbar') {
          positionY = 2.36
        }
				positionX = getAvailablePoint(selectedItem);
				if(!positionX) return;
        updateCrossBars(positionX, selectedItem.type, selectedItem.xRadius);
				updateModelState(1, selectedItem.type, positionX);
			}
		}

		switch (event.target.id) {
      case "airconditioner":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/3fc52045eaa806f8/airconditioner-d.glb";
        break;
      case "maxxair":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/c3eeb44577bd8f6a/maxxair.glb";
        break;
      case "solar_panel250":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/5b0bf30f3bc0bc5b/250W.glb";
        break;
      case "solar_panel200":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/41179ec7afded29e/200W.glb";
        break;
      case "solar_panel100":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/1d5da2011f6c3f84/100W.glb";
        break;
      case "solar_panel50":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/cfce53c8523cbc41/55W.glb";
        break;
      case "solar_panel30":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/dfcf1aaf24802514/30W.glb";
        break;
      case "cross_bar":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/543cc594a487aecf/8020_cross.glb";
        break;
      case "ladder":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/e1c66ba4aca3d154/ladder.glb";
        break;
      case "awning":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/85085b43be1cd9cf/awning.glb";
        break;
      case "awning_350":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/431a3b45d712597f/awning_350.glb";
        break;
      case "light_bar":
        loadItemDirectory = "https://cdn.shopify.com/3d/models/226d699f32ba22a3/light_bar.glb";
        break;
    }

    const loadModel = (url) => {
      return new Promise((resolve, reject) => {
        loader.load(url, function (gltf) {
          resolve(gltf.scene);
        }, undefined, reject);
      });
    };

    loadModel(loadItemDirectory)
      .then((modelItem) => {
        model = modelItem;
				model.position.x = positionX;
				model.position.y = positionY;
				model.position.z = positionZ;
				scene.add(model);

				updateSolarArea(positionX, selectedItem.type, 1)
				calcPrice(selectedItem.type, true, model);
      })
      .catch((error) => {
        console.error('An error occurred while loading the model:', error);
      });
  }

  function createOrderedArray(boxesArr) {
    const values = [];
    boxesArr.forEach(box => {
        values.push({ type: 'max', value: -box.min.x * meterToInch });
        values.push({ type: 'min', value: -box.max.x * meterToInch });
    });

    values.sort((a, b) => a.value - b.value);

    const result = [];
    let minIndex = 0;
    let maxIndex = 1;

    values.forEach(item => {
        if (item.type === 'min') {
            result[minIndex] = item.value;
            minIndex += 2;
        } else {
            result[maxIndex] = item.value;
            maxIndex += 2;
        }
    });
    return result;
  }

  function gotoCheckout(token) {
    window.open(`/checkouts/cn/${token}`, '_blank')
  }

  function resetConfig(temp) {
    if(temp){fromTemplate = temp;}
    let models = scene.children.filter((group) => 
      group?.children[0]?.name == 'maxxair' || 
      group?.children[0]?.name == 'air_conditioner' || 
      group?.children[0]?.name == 'solar250' || 
      group?.children[0]?.name == 'solar200' || 
      group?.children[0]?.name == 'solar100' || 
      group?.children[0]?.name == 'solar55' || 
      group?.children[0]?.name == 'solar30'|| 
      group?.children[0]?.name == 'ladder' );

    for(let x in models) {
      scene.remove(models[x])
    }

    let productList = [...availableProducts]

    productList = productList.map(product => {
      let newProduct = {...product};

      if(newProduct.type == 'rack') newProduct.quantity = 1;
      else newProduct.quantity = 0;

      handleDisableResetBtn()

      return newProduct
    });

    availableProducts = productList;

    addedState = [];
		selectedIndexOfState = -1;
		solar35Area = [];
		solar55Area = [];

    updateCartState()
    updateBuildState(productList)
    calculatePrice(productList)
  }

  function doMouseDown(x, y) {
    controls.enableRotate = false;
    if (selectedFeature) {
      removeEdgeLines(selectedFeature);
      selectedFeature = null;
      selectedIndexOfState = -1;
    }
    scene.remove(targetForDragging);
    delelteBtn.disabled = true;

    let a = 2 * x / ((window.innerWidth < 1024 ? window.innerWidth : window.innerWidth - 300)) - 1;
    let b = 1 - 2 * y / window.innerHeight;
    raycaster.setFromCamera(new THREE.Vector2(a, b), camera);
    intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length == 0) {
      return false;
    }
    let item = intersects[0];
    let objectHit = item.object;

    if (objectHit.parent &&
      objectHit.parent.name != "" &&
      objectHit.parent.name != "van" &&
      objectHit.name?.includes('roof_rack') != true &&
      objectHit != workPlane &&
      objectHit != shodowMesh) {
      scene.add(targetForDragging);
      targetForDragging.position.set(0, item.point.y, 0);

      if (objectHit != selectedFeature) {
        selectedFeature = objectHit;
        addEdgeLines(selectedFeature);
        delelteBtn.disabled = false;
        selectedIndexOfState = checkIsAvailable(objectHit.parent.position.x, selectedFeature.name, 3);
      }
      else {
        selectedFeature = null;
        removeEdgeLines(selected);
        delelteBtn.disabled = true;
        selectedIndexOfState = -1;
      }
      render();
    }
  }


  function addEdgeLines(object) {
    if (edgeLine) {
      object.remove(edgeLine);
      edgeLine.geometry.dispose();
      edgeLine.material.dispose();
    }
    const edges = new THREE.EdgesGeometry(object.geometry);
    edgeLine = new THREE.LineSegments(edges, lineMaterial);
    object.add(edgeLine);
  }

  function removeEdgeLines(object) {
    if (edgeLine) {
      object.remove(edgeLine);
      edgeLine.geometry.dispose();
      edgeLine.material.dispose();
      edgeLine = null;
    }
  }

  function calcPrice(modelName, flag, model) {
    let addProduct = {}

    console.log("calc price: ", modelName)

    switch (modelName) {
      case "air_conditioner":
        if(fromTemplate) {
          addProduct = availableProducts[10];
          flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
          addProduct.model = model;
          availableProducts[10] = addProduct;
        }
        else {
          addProduct = availableProducts[1];
          flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
          addProduct.model = model;
          availableProducts[1] = addProduct;
        }
        break;
      case "maxxair":
        addProduct = availableProducts[2];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        addProduct.model = model;
        availableProducts[2] = addProduct;
        break;
      case "solar200":
        addProduct = availableProducts[3];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        addProduct.model = model;
        availableProducts[3] = addProduct;

        addProduct = availableProducts[7];
        if(addProduct.quantity > 0 && !flag){
          addProduct.quantity -= 1;
        } else if(flag) {
          addProduct.quantity += 1;
        }
        availableProducts[7] = addProduct;

        break;
      case "solar100":
        addProduct = availableProducts[15];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        availableProducts[15] = addProduct;
        break;
      case "solar250":
        addProduct = availableProducts[16];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        availableProducts[16] = addProduct;
        break;
      case "solar55":
        addProduct = availableProducts[4];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        addProduct.model = model;
        availableProducts[4] = addProduct;

        addProduct = availableProducts[8];
        if(addProduct.quantity > 0 && !flag){
          addProduct.quantity -= 1;
        } else if(flag) {
          addProduct.quantity += 1;
        }
        availableProducts[8] = addProduct;
        
        break;
      case "solar30":
        addProduct = availableProducts[5];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        addProduct.model = model;
        availableProducts[5] = addProduct;

        addProduct = availableProducts[6];
        if(addProduct.quantity > 0 && !flag){
          addProduct.quantity -= 1;
        } else if(flag) {
          addProduct.quantity += 1;
        }
        availableProducts[6] = addProduct;

        break;
      case "ladder":
        addProduct = availableProducts[9];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        addProduct.model = model;
        availableProducts[9] = addProduct;
        break;
      case "awning":
        addProduct = availableProducts[13];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        availableProducts[13] = addProduct;

        addProduct = availableProducts[14];
        if(addProduct.quantity > 0 && !flag){
          addProduct.quantity -= 1;
        } else if(flag) {
          addProduct.quantity += 1;
        }
        availableProducts[14] = addProduct;

        break;
      case "awning_350":
        addProduct = availableProducts[17];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        availableProducts[17] = addProduct;

        addProduct = availableProducts[14];
        if(addProduct.quantity > 0 && !flag){
          addProduct.quantity -= 1;
        } else if(flag) {
          addProduct.quantity += 1;
        }
        availableProducts[14] = addProduct;
        break;

      case "light_bar":
        addProduct = availableProducts[18];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        availableProducts[18] = addProduct;
        break;

      case "8020_crossbar":
        addProduct = availableProducts[11];
        flag ? addProduct.quantity += 1 : addProduct.quantity -= 1;
        availableProducts[11] = addProduct;
        break;

      default:
        break;
    }
    updateCartState();
    calculatePrice(availableProducts)
    updateBuildState(availableProducts);
  }

  function updateCartState() {
    let totalItems = 0;
    availableProducts.map((product) => {
      let productAmount = product.quantity; 
      if(product?.type == 'solar_cross') {
        if(productAmount <= 2) productAmount = 0;
        else productAmount -= 2;
      }
      totalItems += productAmount
      if(product.htmlId != "") {
        if(document.getElementById(product.htmlId)) {
          let dragItem = document.getElementById(product.htmlId).childNodes[1];
          if (product.quantity > 0) {
            dragItem.innerHTML = product?.quantity.toString();
            dragItem.classList.remove("d-none");
            dragItem.classList.add("d-block");
          } else {
            dragItem.classList.remove("d-block");
            dragItem.classList.add("d-none");
          }
        }
      }
    });
    document.getElementById('products-num').innerHTML = totalItems
  }

  function setViewCube() {
    clock = new THREE.Clock();
    helper = new ViewHelper(camera, renderer.domElement);
    helper.controls = controls;
    helper.controls.center = controls.target;
    const div = document.createElement('div');
    div.id = 'viewHelper';
    div.style.position = 'absolute';
    div.style.right = 0;
    div.style.bottom = 0;
    div.style.height = '128px';
    div.style.width = '128px';
    div.style.zIndex = 100

    document.getElementById("configurator-container").appendChild(div);
    div.addEventListener('pointerup', (event) => {
      helper.handleClick(event)
    });
    animate();

    if(window.innerWidth < 1024) helper.visible = false;
  }

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    if (helper.animating) helper.update(delta);
    helper.render(renderer);
  }

  function setCameraView() {
    controls = new OrbitControls(camera, container);
    controls.maxDistance = 15;
    controls.minDistance = 4;
    controls.maxZoom = 3;
    controls.minZoom = 0.5;
    controls.maxPolarAngle = THREE.MathUtils.degToRad(90);
    controls.screenSpacePanning = false;
    controls.target.set(0, 0.5, 0);
  }

  function init() {
    const container = document.getElementById('container');
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(((window.innerWidth < 1024 ? window.innerWidth : window.innerWidth - 300)), window.innerHeight);
    renderer.setAnimationLoop(render);
    renderer.toneMappingExposure = 0.85;
    renderer.autoClear = false;
    container.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize);

    camera = new THREE.PerspectiveCamera(40, ((window.innerWidth < 1024 ? window.innerWidth : window.innerWidth - 300)) / window.innerHeight, 1, 10000);
    camera.position.set(-1, 6, -6);
    camera.aspect = ((window.innerWidth < 1024 ? window.innerWidth : window.innerWidth - 300)) / (window.innerHeight);
    camera.updateProjectionMatrix();
    setCameraView();

    scene = new THREE.Scene();
    scene.background = new THREE.Color("#ffffff");
    setViewCube();

    const directionalLight1 = new THREE.DirectionalLight(0xffffff, 2.5);
    directionalLight1.position.set(1, 1, 0);
    scene.add(directionalLight1);

    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 2.5);
    directionalLight2.position.set(-1, 1, 0);
    scene.add(directionalLight2);

    const directionalLight3 = new THREE.DirectionalLight(0xffffff, 2.5);
    directionalLight3.position.set(0, 1, 1);
    scene.add(directionalLight3);

    const directionalLight4 = new THREE.DirectionalLight(0xffffff, 2.5);
    directionalLight4.position.set(0, 1, -1);
    scene.add(directionalLight4);

    const ambientLight = new THREE.AmbientLight('#ffffff', 1); // color, intensity
    scene.add(ambientLight);

    const hdrLoader = new RGBELoader();
    hdrLoader.loadAsync( 'https://cdn.shopify.com/s/files/1/0412/9898/5124/files/mt1.hdr?v=1715607373' ).then(envMap=>{
      envMap.mapping = THREE.EquirectangularReflectionMapping;
      const params = {
        height: 15,
        radius: 100,
        enabled: true,
      };
      let skybox = new GroundedSkybox( envMap, params.height, params.radius );
      skybox.position.y = params.height - 0.01;
      scene.add( skybox );
      scene.environment = envMap;
    });

    
  }

  function getModelBoundingBox(mesh) {
    const box = new THREE.Box3().setFromObject(mesh);
    return box;
  }

  function isCrossBarCollied(selectedFeatureBoundingBox, collidableMeshList, xPos) {
    const widthOfObject = Math.abs(selectedFeatureBoundingBox.max.x - selectedFeatureBoundingBox.min.x);
    const filteredCollidableMeshList = collidableMeshList.filter(box => !(box.min.x.toFixed(3) == selectedFeatureBoundingBox.min.x.toFixed(3) && box.max.x.toFixed(3) == selectedFeatureBoundingBox.max.x.toFixed(3)));
    let collisionDetected = false;

    for (let boundingBox of filteredCollidableMeshList) {
      const centerItem = (boundingBox.min.x + boundingBox.max.x) /2;
      if ( ((xPos - widthOfObject/2) < boundingBox.max.x && (xPos + widthOfObject/2) > boundingBox.min.x)) {
        collisionDetected = true;
        break;
      }
    }
    return collisionDetected; 
  }

  function isColliedNearBy(selectedFeatureBoundingBox, box2, collidableMeshList, xPos) {
    const widthOfObject = Math.abs(selectedFeatureBoundingBox.max.x - selectedFeatureBoundingBox.min.x);
    const filteredCollidableMeshList = collidableMeshList.filter(box => !(box.min.x.toFixed(3) == selectedFeatureBoundingBox.min.x.toFixed(3) && box.max.x.toFixed(3) == selectedFeatureBoundingBox.max.x.toFixed(3)) && !(box.min.x.toFixed(3) == box2.min.x.toFixed(3) && box.max.x.toFixed(3) == box2.max.x.toFixed(3)));
    let collisionDetected = false;

    for (let boundingBox of filteredCollidableMeshList) {
      const centerItem = (boundingBox.min.x + boundingBox.max.x) /2;
      if ( ((xPos - widthOfObject/2) < boundingBox.max.x && (xPos + widthOfObject/2) > boundingBox.min.x)) {
        collisionDetected = true;
        break;
      }
    }
    return collisionDetected; 
  }

  function updateColliderList() {
    const collidableModels = ["cross_bar", "maxxair", "air_conditioner", "solar200", "solar250", "solar100", "lshape_cross", "8020_crossbar", "solar30", "solar55"];
    let models = scene.children.filter((group) => collidableModels.includes(group?.children[0]?.name));

    const boxes = models.map((model) => {
      return getModelBoundingBox(model)
    });
    return boxes
  }

  function onWindowResize() {
    if(window.innerWidth < 1024) {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      helper.visible = false;
    } else {
      camera.aspect = (window.innerWidth - 300) / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize((window.innerWidth - 300), window.innerHeight);
      helper.visible = true;
    }
  }

  function render() {
    controls.update();
    renderer.render(scene, camera);
  }

  function isValueInScale(value, scale, radius, vanDiff) {
    for (let i = 0; i < scale.length; i += 2) {
        if (value + 100 >= (scale[i] + radius - vanDiff + 100 ) && value + 100 <= (scale[i + 1] - radius - vanDiff + 100)) {
          return i;
        }
    }
    return -1;
  }

  function updateSolarArea(xPos, modelName, flag) {
    let productInfo = availableProducts.filter((product) => product.type == modelName)[0];
    let xRadius = productInfo.xRadius;
    let inchXPos = -1 * xPos/0.0254;
    let startValue = inchXPos - xRadius;
    let endValue = inchXPos + xRadius;

    if(modelName == "air_conditioner"){
      if(solar35Area.length > 0 && flag == 2){
        let curArea = [...solar35Area];
        const indexOfModel = getPositionIndex(curArea, inchXPos, xRadius);
        if(indexOfModel >= 0) {
          const newArea = {
            position: inchXPos,
            confState: curArea[indexOfModel].confState,
            moved: true
          }
          curArea[indexOfModel] = newArea;
          solar35Area = curArea;
        }
      } else {
        const newArea = {
          position: inchXPos,
          confState: false,
          moved: false
        }
        solar35Area.push(newArea)
      }
    } else if(modelName == "maxxair"){
      if(solar55Area.length > 0 && flag == 2){
        let curArea = [...solar55Area];
        const indexOfModel = getPositionIndex(curArea, inchXPos, xRadius);
        if(indexOfModel >= 0) {
          const newArea = {
            position: inchXPos,
            confState: curArea[indexOfModel].confState,
            moved: true
          }
          curArea[indexOfModel] = newArea;
          solar55Area = curArea;
        }
      } else {
        const newArea = {
          position: inchXPos,
          confState: false,
          moved: false
        }
        solar55Area.push(newArea)
      }
    }
  }

  function checkIsAvailable(xPos, modelName, flag) {
    let productInfo = availableProducts.filter((product) => product.type == modelName)[0];
    let xRadius = productInfo.xRadius;
    let inchXPos = -1 * xPos/0.0254;
    let startValue = inchXPos - xRadius;
    let endValue = inchXPos + xRadius;
    let startPointCheck, endPointCheck, centerPointCheck = -1;

    const curState = getAddedState();

    if(startValue < vanArea[0] || endValue > vanArea[1]) return false;
    
    if(flag == 1) {
      startPointCheck = isValueInScale(startValue, curState, 0, 0);
      endPointCheck = isValueInScale(endValue, curState, 0, 0);
      centerPointCheck = isValueInScale(inchXPos, curState, 0, 0);
    } else if(flag == 2) {
      const currentState = [...curState];
      if(selectedIndexOfState >= 0)currentState.splice(selectedIndexOfState, 2);
      startPointCheck = isValueInScale(startValue, currentState, 0, 0);
      endPointCheck = isValueInScale(endValue, currentState, 0, 0);
      centerPointCheck = isValueInScale(inchXPos, currentState, 0, 0);

    } else {
      let modelIndex = isValueInScale(inchXPos, curState, 0, 0);
      let startIndex = isValueInScale(inchXPos, curState, xRadius/2, 0);
      let endIndex = isValueInScale(inchXPos, curState, xRadius/2, 0);
      if(modelIndex == startIndex && modelIndex == endIndex) {
        return modelIndex
      } else {
        return -1;
      }
    }
    if(startPointCheck == -1 && endPointCheck == -1 && centerPointCheck == -1) {
      return true;
    } else return false;
  }

  function updateModelState(flag, modelType, xPos) {
    let productInfo = availableProducts.filter((product) => product.type == modelType)[0];
    let xRadius = productInfo.xRadius;
    let inchXPos = -1 * xPos/0.0254
    let startValue = inchXPos - xRadius;
    let endValue = inchXPos + xRadius;

    if(modelType == "ladder") return
    else if(modelType == 'solar55'){
      const selAreaIndex = solar55Area.findIndex((area) => area.position > (inchXPos - xRadius / 2) && area.position < (inchXPos + xRadius / 2));
      let selectedArea = {...solar55Area[selAreaIndex]};
      selectedArea.confState = false;
      if(selAreaIndex >= 0) solar55Area[selAreaIndex] = selectedArea;
      return;

    } else if(modelType == 'solar30') {
      const selAreaIndex = solar35Area.findIndex((area) => area.position > (inchXPos - xRadius / 2) && area.position < (inchXPos + xRadius / 2));
      let selectedArea = {...solar35Area[selAreaIndex]};
      selectedArea.confState = false;
      if(selAreaIndex >= 0) solar35Area[selAreaIndex] = selectedArea;
      return;
    } else if(modelType == 'maxxair' && flag == 3) {
      const selAreaIndex = solar55Area.findIndex((area) => area.position > (inchXPos - xRadius / 2) && area.position < (inchXPos + xRadius / 2));
      if(selAreaIndex >= 0) solar55Area.splice(selAreaIndex, 1);
    }
    else if(modelType == 'air_conditioner' && flag == 3) {
      const selAreaIndex = solar35Area.findIndex((area) => area.position > (inchXPos - xRadius / 2) && area.position < (inchXPos + xRadius / 2));
      if(selAreaIndex >= 0) solar35Area.splice(selAreaIndex, 1);
    }

    switch(flag) {
      case 1: 
        addedState.push(startValue, endValue)
        break;
      case 2: 
        if(selectedIndexOfState >= 0) {
          addedState.splice(selectedIndexOfState, 2);
          addedState.splice(selectedIndexOfState, 0, startValue, endValue)
        }
        break;
      case 3:
        if(selectedIndexOfState >= 0) {
          addedState.splice(selectedIndexOfState, 2);
        }
        break;
    }
  }

  function updateBuildState(products) {
    const buildListDom = document.getElementById('build-list');
    let buildText = ''
    for(let i=0; i < products.length; i++) {
      const availableProduct = products[i];

      let productAmount = availableProduct.quantity; 


      if(availableProduct?.type == 'solar_cross') {
        if(productAmount <= 2) continue;
        else productAmount -= 2;
      }

      if(productAmount > 0) {

        buildText += '<div class="build-item"><div class="item-overview">'
        buildText += '<div class="product-info"><img src="'+ availableProduct?.image +'&width=50" width="50" height="50"/>'
        buildText += '<a class="item-name" href="'+availableProduct?.url + (availableProduct?.id ? ("?variant="+ availableProduct?.id ) : "" ) + '" target="_blank">'+ availableProduct?.title +'</a></div><button class="remove-product" id="'+ (availableProduct?.type + "___") +'">&#10799;</div>'
        if(availableProduct.availability){
          if(availableProduct?.type != "rack") {
            buildText += '<div class="item-variants">'
            availableProduct?.variants?.map((variant, index) => {
              buildText += '<div class="variant"><div>'
              {% comment %} buildText += '<input type="radio" class="variant-handler" id="'+ (availableProduct?.type+"___"+variant?.id) +'" name="'+ availableProduct?.type +'" ' + (Number(variant?.id) == Number(availableProduct?.id) ? 'checked' : '') + '/><label for="'+ (availableProduct?.type+"___"+variant?.id) +'">'+ (variant.public_title ? variant.public_title : variant.name) +'</label>' {% endcomment %}
              buildText += '<label for="'+ (availableProduct?.type+"___"+variant?.id) +'" class="' + (Number(variant?.id) == Number(availableProduct?.id) ? 'selected-variant' : '') + '">'+ (variant.public_title ? variant.public_title : variant.name) +'</label>'
              buildText += '</div><div>'
              buildText += '$<span class="price">'+ variant.price / 100 +'</span>'
              buildText += '</div></div>'
            })
            buildText += '</div>'
          }
        } else {
          buildText += '<div class="not-sell">This item is not available for sale from Unaka Gear Co. Please contact support for any questions</div>'
        }
        buildText += '<div style="display: flex; justify-content: end">Qty. '+ productAmount +'</div>'
        buildText += '<div class="divider"></div></div>'
      }
    }
    buildListDom.innerHTML = buildText;
    buildListDom.addEventListener('click', handleRadioChange);
  }

  function handleRadioChange(event) {
    if (event.target.type === 'radio') {
      const targetVariant = event.target.id?.split('___');
      availableProducts = availableProducts.map((product) => {
        if(targetVariant[0] == product.type) {
          const selectedProduct = product.variants.find((variant) => variant.id == targetVariant[1]);
          let newProduct = {...product, id: selectedProduct.id, price: selectedProduct.price / 100};
          return newProduct;
        }
        else return product;
      });
      calculatePrice(availableProducts)
    } else if(event.target.type === 'submit') {
      const targetType = event.target.id?.split('___')[0];
      if(targetType == 'ac_cross' || targetType == 'solar_cross' || targetType == 'max_cross' || targetType == 'rack') {
        const toRemoveIndex = availableProducts.findIndex((product) => product.type == targetType);
        const quantity = availableProducts[toRemoveIndex].quantity;
        if(quantity > 0) availableProducts[toRemoveIndex].quantity = quantity - 1;
        updateBuildState(availableProducts)
        calculatePrice(availableProducts)
        updateCartState();
      } else {
        const toRemoveModel = availableProducts.find((product) => product.type == targetType)?.model;
        scene.remove(toRemoveModel);
        selectedIndexOfState = checkIsAvailable(toRemoveModel.position.x, toRemoveModel.children[0].name, 3);
        calcPrice(toRemoveModel.children[0].name, false, null)
        updateModelState(3, toRemoveModel.children[0].name, toRemoveModel.position.x)
      }
    }
  }

  function calculatePrice(products) {
    let totalPrice = 0;
    products.map((product) => {
      let productAmount = product.quantity; 

      if(product?.type == 'solar_cross') {
        if(productAmount <= 2) productAmount = 0;
        else productAmount -= 2;
      }

      if(productAmount > 0 && product.availability){
        totalPrice += productAmount * product.price;
      }
    })
    document.getElementById("products-cost").innerHTML = totalPrice.toFixed(2);
  }

  function getPositionIndex(areaArr, pos, radius) {
    const startPoint = pos - radius / 2;
    const endPoint = pos + radius / 2;
    for(let i=0; i< areaArr.length; i++) {
      if(areaArr[i].position > startPoint && areaArr[i].position < endPoint) return i;
    }
    return -1;
  }

  function initVan(vanModelLink, shadowLink, rackModel, crossbarXPos, workPlaneValues, ladderPlaneValues){
    loader.load(vanModelLink, function (gltf) {
      carModel = gltf.scene;

      bodyMesh = carModel.getObjectByName("van").getObjectByName("van_1");
      const bodyMaterial = new THREE.MeshPhysicalMaterial( {
        color: 0xffffff, metalness: 1.0, roughness: 0.9, clearcoat: 1.0, clearcoatRoughness: 0.1
      } );
      bodyMesh.material = bodyMaterial

      const shadow = new THREE.TextureLoader().load(shadowLink);
      shodowMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(2.8, 6.5),
        new THREE.MeshBasicMaterial({
          map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
        })
      );
      shodowMesh.rotation.x = - Math.PI / 2;
      shodowMesh.rotation.z = Math.PI / 2;
      shodowMesh.renderOrder = 2;
      carModel.add(shodowMesh);
      scene.add(carModel);

      loader.load(rackModel,  function (gltf) {
        let rackModel = gltf.scene;
        rackModel.position.y = 2.3222
        rackModel.position.x = -0.755
        scene.add(rackModel);

        let models = [
          {
            path: 'https://cdn.shopify.com/3d/models/543cc594a487aecf/8020_cross.glb',
            xPos: crossbarXPos
          }
        ]
        models.map((model) => {
          loader.load(model.path, function (gltf) {
            let crossBarModel = gltf.scene;
            crossBarModel.position.y = 2.36
            crossBarModel.position.x = model.xPos
            let bbox1 = getModelBoundingBox(crossBarModel);
            scene.add(crossBarModel);
          })
        })
      })

      workPlane = new THREE.Mesh(
        new THREE.BoxGeometry(...workPlaneValues),
        new THREE.MeshLambertMaterial({ color: "green" })
      );
      workPlane.material.visible = false;

      workPlane.position.set(-1.08, 2.37, 0);
      scene.add(workPlane);

      ladderPlane = new THREE.Mesh(
        new THREE.BoxGeometry(...ladderPlaneValues),
        new THREE.MeshLambertMaterial({color: 'green'})
      )
      ladderPlane.material.visible = false;
      ladderPlane.position.set(-1.08, 1.3, -0.85); 
      scene.add(ladderPlane);

      targetForDragging = new THREE.Mesh(
        new THREE.BoxGeometry(100, 0.01, 100),
        new THREE.MeshBasicMaterial()
      );
      targetForDragging.material.visible = false;
      raycaster = new THREE.Raycaster();
    });
  }

  function selectVan() {
    const selectedVan = document.getElementById("van_modal_select").value
    availableProducts = availableProducts.map((product) => {
      if(product.type == "rack") {
        const selectedProduct = product.variants.find((variant) => variant.id == selectedVan);
        let newProduct = {...product, id: selectedProduct.id, price: selectedProduct.price / 100};
        return newProduct;
      }
      else return product;
    });

    {% comment %} let rackModels = scene.children.filter((group) => group?.children[0]?.name?.includes("roof_rack"));

    const vanModel = scene.children.filter((group) => group.children[0]?.name == "van")[0];
    scene.remove(vanModel) {% endcomment %}

    let vanModelLink, shadowLink, rackModel, crossbarXpos, workPlaneValues, ladderPlaneValues;
    switch (selectedVan) {
      case "45730334703835":
        vanModelLink = "https://cdn.shopify.com/3d/models/11ab0e3e276f4fa7/van3.glb";
        shadowLink = "https://cdn.shopify.com/s/files/1/0412/9898/5124/files/ford_ao.png?v=1711858184";
        rackModel = 'https://cdn.shopify.com/3d/models/4df021fd93d74fd4/rack-extended.glb'
        crossbarXpos = -2.52
        workPlaneValues = [3, 0.01, 1.55];
        ladderPlaneValues = [3, 2, 0.01];
        vanArea = [-16.535, 101.968]
        cutOffArea = [3.19, 25.7, 32.09, 64.72, 71.11, 85.19];
        vanDiff = 3.2
        initVan(vanModelLink, shadowLink, rackModel, crossbarXpos, workPlaneValues, ladderPlaneValues)
        break;

      case "45730334671067":
        vanModelLink = "https://cdn.shopify.com/3d/models/11ab0e3e276f4fa7/van3.glb";
        shadowLink = "https://cdn.shopify.com/s/files/1/0412/9898/5124/files/ford_ao.png?v=1711858184";
        rackModel = 'https://cdn.shopify.com/3d/models/bc8d1e88f7780c06/rack_origin.glb'
        crossbarXpos = -2.52
        workPlaneValues = [3, 0.01, 1.55];
        ladderPlaneValues = [3, 2, 0.01];
        vanArea = [-16.535, 101.968]
        cutOffArea = [3.19, 25.7, 32.09, 64.72, 71.11, 85.19];
        vanDiff = 3.2
        initVan(vanModelLink, shadowLink, rackModel, crossbarXpos, workPlaneValues, ladderPlaneValues);
        break;

      case "45730334802139":
        vanModelLink = "https://cdn.shopify.com/3d/models/f1feb21f361e67a7/van-ext.glb";
        shadowLink = "https://cdn.shopify.com/s/files/1/0412/9898/5124/files/ford_ao.png?v=1711858184";
        rackModel = 'https://cdn.shopify.com/3d/models/8858a79a0b36c2f1/transit148-ext-rack.glb'
        crossbarXpos = -3.24
        workPlaneValues = [3, 0.01, 1.55];
        ladderPlaneValues = [3, 2, 0.01];
        vanArea = [-16.535, 129.527]
        cutOffArea = [3.2, 25.7, 32.09, 64.72, 71.11, 85.19, 91.58, 101.33, 107.72, 124.72];
        vanDiff = 3.2
        initVan(vanModelLink, shadowLink, rackModel, crossbarXpos, workPlaneValues, ladderPlaneValues);
        break;

      case "45730334834907":
        vanModelLink = "https://cdn.shopify.com/3d/models/f1feb21f361e67a7/van-ext.glb";
        shadowLink = "https://cdn.shopify.com/s/files/1/0412/9898/5124/files/ford_ao.png?v=1711858184";
        rackModel = 'https://cdn.shopify.com/3d/models/278cf2f4a6faa586/transit148-ext-rack-lightbar.glb'
        crossbarXpos = -3.24
        workPlaneValues = [3, 0.01, 1.55];
        ladderPlaneValues = [3, 2, 0.01];
        vanArea = [-16.535, 129.527]
        cutOffArea = [3.2, 25.7, 32.09, 64.72, 71.11, 85.19, 91.58, 101.33, 107.72, 124.72];
        vanDiff = 3.2
        initVan(vanModelLink, shadowLink, rackModel, crossbarXpos, workPlaneValues, ladderPlaneValues);
        break;
    }

    calculatePrice(availableProducts)

    document.getElementById("van_modal_area").style.display = 'none'
  }

  init();
</script>

{% schema %}
{
  "name": "t:sections.model-visualization.name",
  "class": "section spacing-section",
  "settings": [
   
  ],
  "presets": [
    {
      "name": "t:sections.model-visualization.presets.name"
    }
  ],
  "disabled_on": {
    "groups": [
      "custom.overlay"
    ]
  }
}
{% endschema %}